Studio 8 write up

Your TA's name:



Students in your studio group:

    Name        Student ID (begins with a 4)
	
1.Bridget Wang	456190
2.Sylvia Dai	456114
3.
4.
5.
6.


What distribution do you see plotted (in the histogram or an XY Scatter plot) for Color hashcodes?
Uniform


If the distribution were not uniform, what would the plot look like?
It would take much longer (Theta(n) instead of Theta(1)) to find
How many Color objects are added to the set?
3 Color objects
How many objects are contained in the set after all Color objects are added?
2 objects
Why are the above two numbers different?
Because a set does not allow duplicates, and there are two objects
(that we are trying to add that are the same), so the set
only contains 2 Color objects


Are the Point objects' hash values distributed uniformly?
Yes

How many Point objects are added to the set?
2

How many Point objects are in the set after all Point objects are added?
2

What is wrong with this result?
The two Point objects are the same, so there should be only 1 in the set
Based on the code you see in Point, how is equality determined between two Point objects?
First compare the two objects (values), and then make sure the object
is not null. Then look at the class, and compare the x and y coordinates. 
(Basically check if they are the same, and then check if they are different)
Looking at the output in the console window, how does the implementation of hashCode() for Point explain the bad behavior in the set of Points?
hashCode() is generated by using random numbers, which results in the bad behavior. 

How well does your hash function fare in terms of uniformly distributed hash values for the random point objects?
Although it also returns an uniform distribution,
it is not able to return the same hashCode() for objects that are the same. 

As a team, try out some ideas for Pancake's hashCode() implementation. Record your best idea in the studio8.txt file (here!):
int hash = radius * 17;
if (wheat) { hash = hash + 11};
return hash;

Based on the hashCode() implementation shown to you on the web page, answer the following questions:

If two Pancake objects equal each other, will they get the same hashCode() results?
Yes. 

How good of a job does the implementation do of obtaining uniform distributions of hashCode() values for two Pancake objects that do not equal each other?
It will give a pretty good uniform distribution of the hashCodes, 
but it is still possible for two different pancakes to have the same hashcode. 

Just by inspection of the hashCode() method on the web page, state two Pancakes that are different yet have the same hashCode() value.
Non-wheat pancake with radius 10 = 10
Wheat pancake with radius 5 = 10

Your best hashCode() for Pancake (paste the method here please):
@Override
	public int hashCode(){
		int hash = radius * 17;
		if (wheat){
			hash = hash + 11;
		}
		return hash;
	}

Do your hashCode() values for Pancake appear to be uniformly distributed?
Yes. 


Your implementation of Syrup's hashCode() -- paste here:







How uniformly distributed are your Syrup hashCode() values?



How uniformly distributed are your PancakeAndSyrup hashCode() values?













